Reconhecendo padroes em texto e algoritimo de KMP

Definindo um padrao p e um texto t:
p = {p0,p1,..,pm}
t = {t0,t2,...,tn}
Ideia de dar um "CTLR+F" em t para achar p.

Algoritimo naive = O(n*m), tetando encaixar p em todas as posiçoes de t;

Funçao Z sob uma string S

Zi = 0 se i == 0;
   = tamnho da maior prefixo comum de S com S[i...n-1]
	
		Exemplo:
		S = abacaba
		Z = 0010301

		S = aaaaa
		Z = 054321

Agora, definindo o algoritmo, no seguinte exemplo:
	
	abc#abctesteabctesteabc, onde abc e o meu padrao, logo S = p#t(padrao#termo).
	se Zi == |p| => i e um começo de ocorrencia

	Definindo a funçao Z:

	z[t.size()] = {0,...,0}; // Inicializar vetor z com zeros
	int l = r = 0;
	for (i = 1; i < s.size(); i++){
		if (i <= r) z[i] = min(z[i-l], r-i+1);
		while (z[i] + i < s.size() && s[z[i] + i] == s[z[i]])
			z[i]++;
		if (r < i + z[i] - 1){
			l = i;
			r = i + z[i] - 1;
		}
	}

	essa funçao roda em O(n).

	Tabem podemos usar a funçao Z para definir a menor substring periodica que forma uma dada
	substring. Temos tambem que, essa subtring tem que ter tamanho multiplo da string, ou seja i|n.
	Quando Zi + i = n, onde n e o tamanho da string, temos que i-1 sera o fim da subtring periodica.

Problema original de se reconhecer padroes:
	-Definiçao: borda de S = sufixo de S que e igual ao prefixo de S.
	Exemplo: abacaba => a = borda && aba = borda.

	-Definiçao - funçao Pi := tamanho da maior borda de S[0, ..., i-1].
	Exemplo: 
        S = abacaba
		P = 0010123

		S = aaaaa
		P = 01234

	-Definiçao - S = p#t (padrao#texto)

	-Definindo Pi:

		for (i = 2; i <= s.size(); i++){ // Nao tenho ctz se ta certo
			p[i] = p[i-1];
			while (p[i] > 0 && s[p[i]] != s[i-1])
				p[i] = p[p[i]];
			if (s[p[i]] == s[i-1])
				p[i]++;
		}

		que roda em O(n).

KMP
    
    Ideia de so se calcular a funçao P para o padrao p, onde k ira guardar
    P[i-1]. Roda em O(n). A unica memoria extra gasta e na padrao.

    pi = funçaoPi(padrao); // Inicializando pi com os calculos para o padrao 
    for (i = 2; i <= t.size(); i++){        
        while (k > 0 && padrao[k] != t[i-1])
            k = pi[k];
        if (padrao[k] == t[i-1])
            k++; // Quando K chega a padrao.size() encontramos a ocorrencia, ou seja, a posiçao i-1 e o começo doq estava procurando.
    }

https://www.youtube.com/watch?v=btr95inWBaQ -> video aula
http://codeforces.com/group/eqgxxTNwgd/contest/101245 -> Lista ex